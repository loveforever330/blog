---
title: 设计模式
tags: [DesignPattern]
categories: [计算机基础知识]
index_img: https://65728-1316358396.cos.ap-beijing.myqcloud.com/imgs/postUse/202410242248382.webp?imageSlim
banner_img: https://65728-1316358396.cos.ap-beijing.myqcloud.com/imgs/postUse/202410242248382.webp?imageSlim
excerpt: 设计模式中:工厂模式,抽象工厂模式,单例模式,三选一
author: GENCO
date: 2024-10-24 22:49:00
comments: 'waline'
---


## 设计模式:

> 设计模式: 软件设计当中常见问题的典型解决方式,利用建筑设计模式的思想去优化代码
>
> 要求:`高内聚` ,`低耦合` ,`可扩展`,`可复用` 

##### 六大原则:

> 单一职责(`一个类和方法只去做一件事`  )
>
> 里氏替换(`多态,子类可以扩展父类`)
>
> 依赖倒置(`细节依赖抽象,下层依赖上层`) 
>
> 接口隔离(`建立单一接口` )
>
> 迪米特原则(`最少知道,降低耦合` )
>
> 开闭原则(`抽象架构,扩展实现` )   

{%note success%}

 重点: **单例模式、工厂模式、代理模式，三选一** 

单例模式中的双重锁校验代码

{%endnote%}

## 创建型模式:

#### 1. 工厂方法:

+ `业务场景`:多种类型商品不同接口,统一发奖服务搭建场景
+ `实现要点`: 定义一个创建对象的接口,让其子类自己决定实例化哪一个工厂类,工厂模式使其创建过程延迟到子类进行

##### 简单实现:参考菜鸟教程(基础版本)

###### 简单工厂模式:

> 不是一个正式的设计模式,但它是工厂模式的基础.它使用一个单独的工厂类来创建不同的对象，根据传入的参数决定创建哪种类型的对象。

###### **应用实例** :

>  **货物制造**：你需要一种货物，只需从工厂提货，而不需要关心货物的制造过程及其内部实现。

###### **优点** :

1. 调用者只需要知道对象的名称即可创建对象。
2. 扩展性高，如果需要增加新产品，只需扩展一个工厂类即可。
3. 屏蔽了产品的具体实现，调用者只关心产品的接口。

###### **缺点** :

每次增加一个产品时，都需要增加一个具体类和对应的工厂，使系统中类的数量成倍增加，增加了系统的复杂度和具体类的依赖。

###### **结构** :

- 抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。
- 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。
- 抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。
- 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。


<div style="text-align: center;">
    <img src="https://65728-1316358396.cos.ap-beijing.myqcloud.com/imgs/postUse/202410242244720.webp?imageSlim" alt="img" style="zoom:40%;" />
</div>  

### 自己写的实现代码:


















#### 2. 抽象工厂:

+ `业务场景` :替换Redis双集群升级,代理类抽象场景
+ `实现要点` : 提供一个创建一系列相关或者相互依赖对象的接口,而无需要去指定它们的具体的类

##### **简单代码实现:参考菜鸟教程** 

> ##### **超级工厂** 
>
> 围绕一个超级工厂去创建其他工厂,该超级工厂又被称为其他工厂的工厂,此类设计模式属于创建型模式
>
> `对应接口` :负责创建一个相关对象的工厂,不需要显式的指定它们的类,每个生成的工厂都能够按照工厂模式提供对象
>
> ##### 应用实例:
>
> 比如一个汽车行业公司只负责决策,其下有多个子公司生产不同的车
>
> 汽车行业总公司:抽象工厂
>
> 对应的下属子公司:实例工厂
>
> 下属子公司生产出来的车:实际的对象              

##### 优点:

1. 确保同一产品族的对象一起工作
2. 客户端不需要知道每个对象的具体类，简化了代码

##### 缺点:

>  扩展产品族非常困难。增加一个新的产品族需要修改抽象工厂和所有具体工厂的代码。

##### 结构:

- 抽象工厂（Abstract Factory）：声明了一组用于创建产品对象的方法，每个方法对应一种产品类型。抽象工厂可以是接口或抽象类。
- 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责创建具体产品对象的实例。
- 抽象产品（Abstract Product）：定义了一组产品对象的共同接口或抽象类，描述了产品对象的公共方法。
- 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。

实现的类似于工厂也是`继承自` 抽象工厂类,用一个工厂生成器去生成对应的工厂,对应的工厂再去生产`继承自` 不同的抽象类的实例对象. 

<div style="text-align: center;">
    <img src="https://65728-1316358396.cos.ap-beijing.myqcloud.com/imgs/postUse/202410242245926.webp?imageSlim" alt="img" style="zoom:40%;" />
</div>  

##### 自己写的实现代码:

####  3. 单例模式:
+ `业务场景`: :seven:种设计模式,`Effective java` 作者推荐枚举单例模式.

+ `实现要点`: 保证一个类当中仅仅有一个实例,同时提供一个可以访问它的全局访问点. 
+ 
{% note success %}

**重点掌握** :单例模式中的双重锁校验代码

{% endnote %}

##### 具体代码实现:  
{% fold into @答案 %}

```java
public class Singleton{
    private static volatile Singleton singleton = null;
    private Singleton();

    private static Singleton getInstance(){
        //如果未能够创建实例,进入第一个之前,会有一个校验锁
        if(singleton==null){
            synchronized(Singleton.class){
                if(singleton==null){
                    singleton=new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

{% endfold %}
---



## 结构型模式







### 代理模式:

>  
>
> 



## 行为模式: 



###   

### 观察者模式: 

>  





